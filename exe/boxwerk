#!/usr/bin/env ruby
# frozen_string_literal: true

# If Bundler has already been set up (via `bundle exec` or a Bundler binstub),
# re-exec in a clean Ruby process so Boxwerk controls gem loading from scratch.
# This prevents gems being loaded twice (once by Bundler in the main box, once
# by Boxwerk in the root box).
if defined?(Bundler)
  Bundler.with_unbundled_env { exec(RbConfig.ruby, __FILE__, *ARGV) }
end

boxwerk_lib = File.expand_path('../lib', __dir__)
boxwerk_exe = File.expand_path(__FILE__)

# Commands that don't need Ruby::Box (no package boot required).
NO_BOX_COMMANDS = %w[install info help --help -h version --version -v].freeze
# Subset that don't need Bundler or project gems at all.
STANDALONE_COMMANDS = %w[help --help -h version --version -v].freeze

if NO_BOX_COMMANDS.include?(ARGV[0])
  $LOAD_PATH.unshift(boxwerk_lib)
  require 'boxwerk'

  unless STANDALONE_COMMANDS.include?(ARGV[0])
    gemfile = %w[gems.rb Gemfile].find { |f| File.exist?(f) }
    if gemfile
      require 'bundler/setup'
      Bundler.require
    end
  end

  Boxwerk::CLI.run(ARGV, exe_path: boxwerk_exe)
else
  unless defined?(Ruby::Box)
    $stderr.puts 'Error: Ruby::Box is not available.'
    $stderr.puts 'Boxwerk requires Ruby 4.0 or later with Ruby::Box support.'
    exit 1
  end

  unless Ruby::Box.enabled?
    $stderr.puts 'Error: Ruby::Box is not enabled.'
    $stderr.puts 'Set the RUBY_BOX=1 environment variable before starting Ruby.'
    exit 1
  end

  # Load and run in the root box. Boxwerk is loaded first (before Bundler
  # restricts $LOAD_PATH), then project gems are loaded via Bundler. All
  # definitions end up in the root box, inherited by child boxes.
  Ruby::Box.root.eval(<<~RUBY)
    $LOAD_PATH.unshift(#{boxwerk_lib.inspect})
    require 'boxwerk'

    gemfile = %w[gems.rb Gemfile].find { |f| File.exist?(f) }
    if gemfile
      require 'bundler/setup'
      Bundler.require
    end

    Boxwerk::CLI.run(ARGV, exe_path: #{boxwerk_exe.inspect})
  RUBY
end
