#!/usr/bin/env ruby
# frozen_string_literal: true

# If Bundler has already been set up (via `bundle exec` or a Bundler binstub),
# re-exec in a clean Ruby process so Boxwerk controls gem loading from scratch.
# This prevents gems being loaded twice (once by Bundler in the main box, once
# by Boxwerk in the root box).
if defined?(Bundler)
  Bundler.with_unbundled_env do
    exec(RbConfig.ruby, __FILE__, *ARGV)
  end
end

unless defined?(Ruby::Box)
  $stderr.puts "Error: Ruby::Box is not available."
  $stderr.puts "Boxwerk requires Ruby 4.0 or later with Ruby::Box support."
  exit 1
end

unless Ruby::Box.enabled?
  $stderr.puts "Error: Ruby::Box is not enabled."
  $stderr.puts "Set the RUBY_BOX=1 environment variable before starting Ruby."
  exit 1
end

boxwerk_lib = File.expand_path('../lib', __dir__)
boxwerk_exe = File.expand_path(__FILE__)

# Load and run in the root box. Boxwerk is loaded first (before Bundler
# restricts $LOAD_PATH), then project gems are loaded via Bundler. All
# definitions end up in the root box, inherited by child boxes.
Ruby::Box.root.eval(<<~RUBY)
  $LOAD_PATH.unshift(#{boxwerk_lib.inspect})
  require 'boxwerk'

  # Load project gems via Bundler if a Gemfile/gems.rb exists.
  gemfile = %w[gems.rb Gemfile].find { |f| File.exist?(f) }
  if gemfile
    require 'bundler/setup'
    Bundler.require
  end

  Boxwerk::CLI.run(ARGV, exe_path: #{boxwerk_exe.inspect})
RUBY
